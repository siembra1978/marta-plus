// Copyright 2015 The GTFS Specifications Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Protocol definition file for GTFS Realtime.
//
// GTFS Realtime lets transit agencies provide consumers with realtime
// information about disruptions to their service (stations closed, lines not
// operating, important delays etc), location of their vehicles and expected
// arrival times.
//
// This protocol is published at:
// https://github.com/google/transit/tree/master/gtfs-realtime

// @generated by protoc-gen-es v2.10.0 with parameter "target=ts"
// @generated from file gtfs-realtime.proto (package transit_realtime, syntax proto2)
/* eslint-disable */

import type { Message } from "@bufbuild/protobuf";
import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";

/**
 * Describes the file gtfs-realtime.proto.
 */
export const file_gtfs_realtime: GenFile = /*@__PURE__*/
  fileDesc("ChNndGZzLXJlYWx0aW1lLnByb3RvEhB0cmFuc2l0X3JlYWx0aW1lInkKC0ZlZWRNZXNzYWdlEiwKBmhlYWRlchgBIAIoCzIcLnRyYW5zaXRfcmVhbHRpbWUuRmVlZEhlYWRlchIsCgZlbnRpdHkYAiADKAsyHC50cmFuc2l0X3JlYWx0aW1lLkZlZWRFbnRpdHkqBgjoBxDQDyoGCKhGEJBOIu0BCgpGZWVkSGVhZGVyEh0KFWd0ZnNfcmVhbHRpbWVfdmVyc2lvbhgBIAIoCRJRCg5pbmNyZW1lbnRhbGl0eRgCIAEoDjIrLnRyYW5zaXRfcmVhbHRpbWUuRmVlZEhlYWRlci5JbmNyZW1lbnRhbGl0eToMRlVMTF9EQVRBU0VUEhEKCXRpbWVzdGFtcBgDIAEoBBIUCgxmZWVkX3ZlcnNpb24YBCABKAkiNAoOSW5jcmVtZW50YWxpdHkSEAoMRlVMTF9EQVRBU0VUEAASEAoMRElGRkVSRU5USUFMEAEqBgjoBxDQDyoGCKhGEJBOIuECCgpGZWVkRW50aXR5EgoKAmlkGAEgAigJEhkKCmlzX2RlbGV0ZWQYAiABKAg6BWZhbHNlEjEKC3RyaXBfdXBkYXRlGAMgASgLMhwudHJhbnNpdF9yZWFsdGltZS5UcmlwVXBkYXRlEjIKB3ZlaGljbGUYBCABKAsyIS50cmFuc2l0X3JlYWx0aW1lLlZlaGljbGVQb3NpdGlvbhImCgVhbGVydBgFIAEoCzIXLnRyYW5zaXRfcmVhbHRpbWUuQWxlcnQSJgoFc2hhcGUYBiABKAsyFy50cmFuc2l0X3JlYWx0aW1lLlNoYXBlEiQKBHN0b3AYByABKAsyFi50cmFuc2l0X3JlYWx0aW1lLlN0b3ASPwoSdHJpcF9tb2RpZmljYXRpb25zGAggASgLMiMudHJhbnNpdF9yZWFsdGltZS5UcmlwTW9kaWZpY2F0aW9ucyoGCOgHENAPKgYIqEYQkE4i9gsKClRyaXBVcGRhdGUSLgoEdHJpcBgBIAIoCzIgLnRyYW5zaXRfcmVhbHRpbWUuVHJpcERlc2NyaXB0b3ISNAoHdmVoaWNsZRgDIAEoCzIjLnRyYW5zaXRfcmVhbHRpbWUuVmVoaWNsZURlc2NyaXB0b3ISRQoQc3RvcF90aW1lX3VwZGF0ZRgCIAMoCzIrLnRyYW5zaXRfcmVhbHRpbWUuVHJpcFVwZGF0ZS5TdG9wVGltZVVwZGF0ZRIRCgl0aW1lc3RhbXAYBCABKAQSDQoFZGVsYXkYBSABKAUSRAoPdHJpcF9wcm9wZXJ0aWVzGAYgASgLMisudHJhbnNpdF9yZWFsdGltZS5UcmlwVXBkYXRlLlRyaXBQcm9wZXJ0aWVzGmkKDVN0b3BUaW1lRXZlbnQSDQoFZGVsYXkYASABKAUSDAoEdGltZRgCIAEoAxITCgt1bmNlcnRhaW50eRgDIAEoBRIWCg5zY2hlZHVsZWRfdGltZRgEIAEoAyoGCOgHENAPKgYIqEYQkE4auQcKDlN0b3BUaW1lVXBkYXRlEhUKDXN0b3Bfc2VxdWVuY2UYASABKA0SDwoHc3RvcF9pZBgEIAEoCRI7CgdhcnJpdmFsGAIgASgLMioudHJhbnNpdF9yZWFsdGltZS5UcmlwVXBkYXRlLlN0b3BUaW1lRXZlbnQSPQoJZGVwYXJ0dXJlGAMgASgLMioudHJhbnNpdF9yZWFsdGltZS5UcmlwVXBkYXRlLlN0b3BUaW1lRXZlbnQSVQoaZGVwYXJ0dXJlX29jY3VwYW5jeV9zdGF0dXMYByABKA4yMS50cmFuc2l0X3JlYWx0aW1lLlZlaGljbGVQb3NpdGlvbi5PY2N1cGFuY3lTdGF0dXMSagoVc2NoZWR1bGVfcmVsYXRpb25zaGlwGAUgASgOMkAudHJhbnNpdF9yZWFsdGltZS5UcmlwVXBkYXRlLlN0b3BUaW1lVXBkYXRlLlNjaGVkdWxlUmVsYXRpb25zaGlwOglTQ0hFRFVMRUQSXAoUc3RvcF90aW1lX3Byb3BlcnRpZXMYBiABKAsyPi50cmFuc2l0X3JlYWx0aW1lLlRyaXBVcGRhdGUuU3RvcFRpbWVVcGRhdGUuU3RvcFRpbWVQcm9wZXJ0aWVzGv8CChJTdG9wVGltZVByb3BlcnRpZXMSGAoQYXNzaWduZWRfc3RvcF9pZBgBIAEoCRIVCg1zdG9wX2hlYWRzaWduGAIgASgJEmUKC3BpY2t1cF90eXBlGAMgASgOMlAudHJhbnNpdF9yZWFsdGltZS5UcmlwVXBkYXRlLlN0b3BUaW1lVXBkYXRlLlN0b3BUaW1lUHJvcGVydGllcy5Ecm9wT2ZmUGlja3VwVHlwZRJnCg1kcm9wX29mZl90eXBlGAQgASgOMlAudHJhbnNpdF9yZWFsdGltZS5UcmlwVXBkYXRlLlN0b3BUaW1lVXBkYXRlLlN0b3BUaW1lUHJvcGVydGllcy5Ecm9wT2ZmUGlja3VwVHlwZSJYChFEcm9wT2ZmUGlja3VwVHlwZRILCgdSRUdVTEFSEAASCAoETk9ORRABEhAKDFBIT05FX0FHRU5DWRACEhoKFkNPT1JESU5BVEVfV0lUSF9EUklWRVIQAyoGCOgHENAPKgYIqEYQkE4iUAoUU2NoZWR1bGVSZWxhdGlvbnNoaXASDQoJU0NIRURVTEVEEAASCwoHU0tJUFBFRBABEgsKB05PX0RBVEEQAhIPCgtVTlNDSEVEVUxFRBADKgYI6AcQ0A8qBgioRhCQThqbAQoOVHJpcFByb3BlcnRpZXMSDwoHdHJpcF9pZBgBIAEoCRISCgpzdGFydF9kYXRlGAIgASgJEhIKCnN0YXJ0X3RpbWUYAyABKAkSEAoIc2hhcGVfaWQYBCABKAkSFQoNdHJpcF9oZWFkc2lnbhgFIAEoCRIXCg90cmlwX3Nob3J0X25hbWUYBiABKAkqBgjoBxDQDyoGCKhGEJBOKgYI6AcQ0A8qBgioRhCQTiLfCQoPVmVoaWNsZVBvc2l0aW9uEi4KBHRyaXAYASABKAsyIC50cmFuc2l0X3JlYWx0aW1lLlRyaXBEZXNjcmlwdG9yEjQKB3ZlaGljbGUYCCABKAsyIy50cmFuc2l0X3JlYWx0aW1lLlZlaGljbGVEZXNjcmlwdG9yEiwKCHBvc2l0aW9uGAIgASgLMhoudHJhbnNpdF9yZWFsdGltZS5Qb3NpdGlvbhIdChVjdXJyZW50X3N0b3Bfc2VxdWVuY2UYAyABKA0SDwoHc3RvcF9pZBgHIAEoCRJaCg5jdXJyZW50X3N0YXR1cxgEIAEoDjIzLnRyYW5zaXRfcmVhbHRpbWUuVmVoaWNsZVBvc2l0aW9uLlZlaGljbGVTdG9wU3RhdHVzOg1JTl9UUkFOU0lUX1RPEhEKCXRpbWVzdGFtcBgFIAEoBBJLChBjb25nZXN0aW9uX2xldmVsGAYgASgOMjEudHJhbnNpdF9yZWFsdGltZS5WZWhpY2xlUG9zaXRpb24uQ29uZ2VzdGlvbkxldmVsEksKEG9jY3VwYW5jeV9zdGF0dXMYCSABKA4yMS50cmFuc2l0X3JlYWx0aW1lLlZlaGljbGVQb3NpdGlvbi5PY2N1cGFuY3lTdGF0dXMSHAoUb2NjdXBhbmN5X3BlcmNlbnRhZ2UYCiABKA0SUQoWbXVsdGlfY2FycmlhZ2VfZGV0YWlscxgLIAMoCzIxLnRyYW5zaXRfcmVhbHRpbWUuVmVoaWNsZVBvc2l0aW9uLkNhcnJpYWdlRGV0YWlscxrZAQoPQ2FycmlhZ2VEZXRhaWxzEgoKAmlkGAEgASgJEg0KBWxhYmVsGAIgASgJEl4KEG9jY3VwYW5jeV9zdGF0dXMYAyABKA4yMS50cmFuc2l0X3JlYWx0aW1lLlZlaGljbGVQb3NpdGlvbi5PY2N1cGFuY3lTdGF0dXM6EU5PX0RBVEFfQVZBSUxBQkxFEiAKFG9jY3VwYW5jeV9wZXJjZW50YWdlGAQgASgFOgItMRIZChFjYXJyaWFnZV9zZXF1ZW5jZRgFIAEoDSoGCOgHENAPKgYIqEYQkE4iRwoRVmVoaWNsZVN0b3BTdGF0dXMSDwoLSU5DT01JTkdfQVQQABIOCgpTVE9QUEVEX0FUEAESEQoNSU5fVFJBTlNJVF9UTxACIn0KD0Nvbmdlc3Rpb25MZXZlbBIcChhVTktOT1dOX0NPTkdFU1RJT05fTEVWRUwQABIUChBSVU5OSU5HX1NNT09USExZEAESDwoLU1RPUF9BTkRfR08QAhIOCgpDT05HRVNUSU9OEAMSFQoRU0VWRVJFX0NPTkdFU1RJT04QBCLZAQoPT2NjdXBhbmN5U3RhdHVzEgkKBUVNUFRZEAASGAoUTUFOWV9TRUFUU19BVkFJTEFCTEUQARIXChNGRVdfU0VBVFNfQVZBSUxBQkxFEAISFgoSU1RBTkRJTkdfUk9PTV9PTkxZEAMSHgoaQ1JVU0hFRF9TVEFORElOR19ST09NX09OTFkQBBIICgRGVUxMEAUSHAoYTk9UX0FDQ0VQVElOR19QQVNTRU5HRVJTEAYSFQoRTk9fREFUQV9BVkFJTEFCTEUQBxIRCg1OT1RfQk9BUkRBQkxFEAgqBgjoBxDQDyoGCKhGEJBOIusKCgVBbGVydBIyCg1hY3RpdmVfcGVyaW9kGAEgAygLMhsudHJhbnNpdF9yZWFsdGltZS5UaW1lUmFuZ2USOQoPaW5mb3JtZWRfZW50aXR5GAUgAygLMiAudHJhbnNpdF9yZWFsdGltZS5FbnRpdHlTZWxlY3RvchI7CgVjYXVzZRgGIAEoDjIdLnRyYW5zaXRfcmVhbHRpbWUuQWxlcnQuQ2F1c2U6DVVOS05PV05fQ0FVU0USPgoGZWZmZWN0GAcgASgOMh4udHJhbnNpdF9yZWFsdGltZS5BbGVydC5FZmZlY3Q6DlVOS05PV05fRUZGRUNUEi8KA3VybBgIIAEoCzIiLnRyYW5zaXRfcmVhbHRpbWUuVHJhbnNsYXRlZFN0cmluZxI3CgtoZWFkZXJfdGV4dBgKIAEoCzIiLnRyYW5zaXRfcmVhbHRpbWUuVHJhbnNsYXRlZFN0cmluZxI8ChBkZXNjcmlwdGlvbl90ZXh0GAsgASgLMiIudHJhbnNpdF9yZWFsdGltZS5UcmFuc2xhdGVkU3RyaW5nEjsKD3R0c19oZWFkZXJfdGV4dBgMIAEoCzIiLnRyYW5zaXRfcmVhbHRpbWUuVHJhbnNsYXRlZFN0cmluZxJAChR0dHNfZGVzY3JpcHRpb25fdGV4dBgNIAEoCzIiLnRyYW5zaXRfcmVhbHRpbWUuVHJhbnNsYXRlZFN0cmluZxJPCg5zZXZlcml0eV9sZXZlbBgOIAEoDjIlLnRyYW5zaXRfcmVhbHRpbWUuQWxlcnQuU2V2ZXJpdHlMZXZlbDoQVU5LTk9XTl9TRVZFUklUWRIwCgVpbWFnZRgPIAEoCzIhLnRyYW5zaXRfcmVhbHRpbWUuVHJhbnNsYXRlZEltYWdlEkIKFmltYWdlX2FsdGVybmF0aXZlX3RleHQYECABKAsyIi50cmFuc2l0X3JlYWx0aW1lLlRyYW5zbGF0ZWRTdHJpbmcSOAoMY2F1c2VfZGV0YWlsGBEgASgLMiIudHJhbnNpdF9yZWFsdGltZS5UcmFuc2xhdGVkU3RyaW5nEjkKDWVmZmVjdF9kZXRhaWwYEiABKAsyIi50cmFuc2l0X3JlYWx0aW1lLlRyYW5zbGF0ZWRTdHJpbmci2AEKBUNhdXNlEhEKDVVOS05PV05fQ0FVU0UQARIPCgtPVEhFUl9DQVVTRRACEhUKEVRFQ0hOSUNBTF9QUk9CTEVNEAMSCgoGU1RSSUtFEAQSEQoNREVNT05TVFJBVElPThAFEgwKCEFDQ0lERU5UEAYSCwoHSE9MSURBWRAHEgsKB1dFQVRIRVIQCBIPCgtNQUlOVEVOQU5DRRAJEhAKDENPTlNUUlVDVElPThAKEhMKD1BPTElDRV9BQ1RJVklUWRALEhUKEU1FRElDQUxfRU1FUkdFTkNZEAwi3QEKBkVmZmVjdBIOCgpOT19TRVJWSUNFEAESEwoPUkVEVUNFRF9TRVJWSUNFEAISFgoSU0lHTklGSUNBTlRfREVMQVlTEAMSCgoGREVUT1VSEAQSFgoSQURESVRJT05BTF9TRVJWSUNFEAUSFAoQTU9ESUZJRURfU0VSVklDRRAGEhAKDE9USEVSX0VGRkVDVBAHEhIKDlVOS05PV05fRUZGRUNUEAgSDgoKU1RPUF9NT1ZFRBAJEg0KCU5PX0VGRkVDVBAKEhcKE0FDQ0VTU0lCSUxJVFlfSVNTVUUQCyJICg1TZXZlcml0eUxldmVsEhQKEFVOS05PV05fU0VWRVJJVFkQARIICgRJTkZPEAISCwoHV0FSTklORxADEgoKBlNFVkVSRRAEKgYI6AcQ0A8qBgioRhCQTiI3CglUaW1lUmFuZ2USDQoFc3RhcnQYASABKAQSCwoDZW5kGAIgASgEKgYI6AcQ0A8qBgioRhCQTiJxCghQb3NpdGlvbhIQCghsYXRpdHVkZRgBIAIoAhIRCglsb25naXR1ZGUYAiACKAISDwoHYmVhcmluZxgDIAEoAhIQCghvZG9tZXRlchgEIAEoARINCgVzcGVlZBgFIAEoAioGCOgHENAPKgYIqEYQkE4itwQKDlRyaXBEZXNjcmlwdG9yEg8KB3RyaXBfaWQYASABKAkSEAoIcm91dGVfaWQYBSABKAkSFAoMZGlyZWN0aW9uX2lkGAYgASgNEhIKCnN0YXJ0X3RpbWUYAiABKAkSEgoKc3RhcnRfZGF0ZRgDIAEoCRJUChVzY2hlZHVsZV9yZWxhdGlvbnNoaXAYBCABKA4yNS50cmFuc2l0X3JlYWx0aW1lLlRyaXBEZXNjcmlwdG9yLlNjaGVkdWxlUmVsYXRpb25zaGlwEkwKDW1vZGlmaWVkX3RyaXAYByABKAsyNS50cmFuc2l0X3JlYWx0aW1lLlRyaXBEZXNjcmlwdG9yLk1vZGlmaWVkVHJpcFNlbGVjdG9yGoIBChRNb2RpZmllZFRyaXBTZWxlY3RvchIYChBtb2RpZmljYXRpb25zX2lkGAEgASgJEhgKEGFmZmVjdGVkX3RyaXBfaWQYAiABKAkSEgoKc3RhcnRfdGltZRgDIAEoCRISCgpzdGFydF9kYXRlGAQgASgJKgYI6AcQ0A8qBgioRhCQTiKKAQoUU2NoZWR1bGVSZWxhdGlvbnNoaXASDQoJU0NIRURVTEVEEAASDQoFQURERUQQARoCCAESDwoLVU5TQ0hFRFVMRUQQAhIMCghDQU5DRUxFRBADEg8KC1JFUExBQ0VNRU5UEAUSDgoKRFVQTElDQVRFRBAGEgsKB0RFTEVURUQQBxIHCgNORVcQCCoGCOgHENAPKgYIqEYQkE4iowIKEVZlaGljbGVEZXNjcmlwdG9yEgoKAmlkGAEgASgJEg0KBWxhYmVsGAIgASgJEhUKDWxpY2Vuc2VfcGxhdGUYAyABKAkSYQoVd2hlZWxjaGFpcl9hY2Nlc3NpYmxlGAQgASgOMjgudHJhbnNpdF9yZWFsdGltZS5WZWhpY2xlRGVzY3JpcHRvci5XaGVlbGNoYWlyQWNjZXNzaWJsZToITk9fVkFMVUUiaQoUV2hlZWxjaGFpckFjY2Vzc2libGUSDAoITk9fVkFMVUUQABILCgdVTktOT1dOEAESGQoVV0hFRUxDSEFJUl9BQ0NFU1NJQkxFEAISGwoXV0hFRUxDSEFJUl9JTkFDQ0VTU0lCTEUQAyoGCOgHENAPKgYIqEYQkE4isAEKDkVudGl0eVNlbGVjdG9yEhEKCWFnZW5jeV9pZBgBIAEoCRIQCghyb3V0ZV9pZBgCIAEoCRISCgpyb3V0ZV90eXBlGAMgASgFEi4KBHRyaXAYBCABKAsyIC50cmFuc2l0X3JlYWx0aW1lLlRyaXBEZXNjcmlwdG9yEg8KB3N0b3BfaWQYBSABKAkSFAoMZGlyZWN0aW9uX2lkGAYgASgNKgYI6AcQ0A8qBgioRhCQTiKmAQoQVHJhbnNsYXRlZFN0cmluZxJDCgt0cmFuc2xhdGlvbhgBIAMoCzIuLnRyYW5zaXRfcmVhbHRpbWUuVHJhbnNsYXRlZFN0cmluZy5UcmFuc2xhdGlvbho9CgtUcmFuc2xhdGlvbhIMCgR0ZXh0GAEgAigJEhAKCGxhbmd1YWdlGAIgASgJKgYI6AcQ0A8qBgioRhCQTioGCOgHENAPKgYIqEYQkE4iwQEKD1RyYW5zbGF0ZWRJbWFnZRJJCg9sb2NhbGl6ZWRfaW1hZ2UYASADKAsyMC50cmFuc2l0X3JlYWx0aW1lLlRyYW5zbGF0ZWRJbWFnZS5Mb2NhbGl6ZWRJbWFnZRpTCg5Mb2NhbGl6ZWRJbWFnZRILCgN1cmwYASACKAkSEgoKbWVkaWFfdHlwZRgCIAIoCRIQCghsYW5ndWFnZRgDIAEoCSoGCOgHENAPKgYIqEYQkE4qBgjoBxDQDyoGCKhGEJBOIkMKBVNoYXBlEhAKCHNoYXBlX2lkGAEgASgJEhgKEGVuY29kZWRfcG9seWxpbmUYAiABKAkqBgjoBxDQDyoGCKhGEJBOIoQFCgRTdG9wEg8KB3N0b3BfaWQYASABKAkSNQoJc3RvcF9jb2RlGAIgASgLMiIudHJhbnNpdF9yZWFsdGltZS5UcmFuc2xhdGVkU3RyaW5nEjUKCXN0b3BfbmFtZRgDIAEoCzIiLnRyYW5zaXRfcmVhbHRpbWUuVHJhbnNsYXRlZFN0cmluZxI5Cg10dHNfc3RvcF9uYW1lGAQgASgLMiIudHJhbnNpdF9yZWFsdGltZS5UcmFuc2xhdGVkU3RyaW5nEjUKCXN0b3BfZGVzYxgFIAEoCzIiLnRyYW5zaXRfcmVhbHRpbWUuVHJhbnNsYXRlZFN0cmluZxIQCghzdG9wX2xhdBgGIAEoAhIQCghzdG9wX2xvbhgHIAEoAhIPCgd6b25lX2lkGAggASgJEjQKCHN0b3BfdXJsGAkgASgLMiIudHJhbnNpdF9yZWFsdGltZS5UcmFuc2xhdGVkU3RyaW5nEhYKDnBhcmVudF9zdGF0aW9uGAsgASgJEhUKDXN0b3BfdGltZXpvbmUYDCABKAkSTwoTd2hlZWxjaGFpcl9ib2FyZGluZxgNIAEoDjIpLnRyYW5zaXRfcmVhbHRpbWUuU3RvcC5XaGVlbGNoYWlyQm9hcmRpbmc6B1VOS05PV04SEAoIbGV2ZWxfaWQYDiABKAkSOQoNcGxhdGZvcm1fY29kZRgPIAEoCzIiLnRyYW5zaXRfcmVhbHRpbWUuVHJhbnNsYXRlZFN0cmluZyJDChJXaGVlbGNoYWlyQm9hcmRpbmcSCwoHVU5LTk9XThAAEg0KCUFWQUlMQUJMRRABEhEKDU5PVF9BVkFJTEFCTEUQAioGCOgHENAPKgYIqEYQkE4i3wQKEVRyaXBNb2RpZmljYXRpb25zEkkKDnNlbGVjdGVkX3RyaXBzGAEgAygLMjEudHJhbnNpdF9yZWFsdGltZS5UcmlwTW9kaWZpY2F0aW9ucy5TZWxlY3RlZFRyaXBzEhMKC3N0YXJ0X3RpbWVzGAIgAygJEhUKDXNlcnZpY2VfZGF0ZXMYAyADKAkSRwoNbW9kaWZpY2F0aW9ucxgEIAMoCzIwLnRyYW5zaXRfcmVhbHRpbWUuVHJpcE1vZGlmaWNhdGlvbnMuTW9kaWZpY2F0aW9uGrQCCgxNb2RpZmljYXRpb24SOwoTc3RhcnRfc3RvcF9zZWxlY3RvchgBIAEoCzIeLnRyYW5zaXRfcmVhbHRpbWUuU3RvcFNlbGVjdG9yEjkKEWVuZF9zdG9wX3NlbGVjdG9yGAIgASgLMh4udHJhbnNpdF9yZWFsdGltZS5TdG9wU2VsZWN0b3ISKAodcHJvcGFnYXRlZF9tb2RpZmljYXRpb25fZGVsYXkYAyABKAU6ATASPAoRcmVwbGFjZW1lbnRfc3RvcHMYBCADKAsyIS50cmFuc2l0X3JlYWx0aW1lLlJlcGxhY2VtZW50U3RvcBIYChBzZXJ2aWNlX2FsZXJ0X2lkGAUgASgJEhoKEmxhc3RfbW9kaWZpZWRfdGltZRgGIAEoBCoGCOgHENAPKgYIqEYQkE4aQwoNU2VsZWN0ZWRUcmlwcxIQCgh0cmlwX2lkcxgBIAMoCRIQCghzaGFwZV9pZBgCIAEoCSoGCOgHENAPKgYIqEYQkE4qBgjoBxDQDyoGCKhGEJBOIkYKDFN0b3BTZWxlY3RvchIVCg1zdG9wX3NlcXVlbmNlGAEgASgNEg8KB3N0b3BfaWQYAiABKAkqBgjoBxDQDyoGCKhGEJBOIk8KD1JlcGxhY2VtZW50U3RvcBIbChN0cmF2ZWxfdGltZV90b19zdG9wGAEgASgFEg8KB3N0b3BfaWQYAiABKAkqBgjoBxDQDyoGCKhGEJBOQh0KG2NvbS5nb29nbGUudHJhbnNpdC5yZWFsdGltZQ");

/**
 * The contents of a feed message.
 * A feed is a continuous stream of feed messages. Each message in the stream is
 * obtained as a response to an appropriate HTTP GET request.
 * A realtime feed is always defined with relation to an existing GTFS feed.
 * All the entity ids are resolved with respect to the GTFS feed.
 * Note that "required" and "optional" as stated in this file refer to Protocol
 * Buffer cardinality, not semantic cardinality.  See reference.md at
 * https://github.com/google/transit/tree/master/gtfs-realtime for field
 * semantic cardinality.
 *
 * @generated from message transit_realtime.FeedMessage
 */
export type FeedMessage = Message<"transit_realtime.FeedMessage"> & {
  /**
   * Metadata about this feed and feed message.
   *
   * @generated from field: required transit_realtime.FeedHeader header = 1;
   */
  header?: FeedHeader;

  /**
   * Contents of the feed.
   *
   * @generated from field: repeated transit_realtime.FeedEntity entity = 2;
   */
  entity: FeedEntity[];
};

/**
 * Describes the message transit_realtime.FeedMessage.
 * Use `create(FeedMessageSchema)` to create a new message.
 */
export const FeedMessageSchema: GenMessage<FeedMessage> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 0);

/**
 * Metadata about a feed, included in feed messages.
 *
 * @generated from message transit_realtime.FeedHeader
 */
export type FeedHeader = Message<"transit_realtime.FeedHeader"> & {
  /**
   * Version of the feed specification.
   * The current version is 2.0.  Valid versions are "2.0", "1.0".
   *
   * @generated from field: required string gtfs_realtime_version = 1;
   */
  gtfsRealtimeVersion: string;

  /**
   * @generated from field: optional transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];
   */
  incrementality: FeedHeader_Incrementality;

  /**
   * This timestamp identifies the moment when the content of this feed has been
   * created (in server time). In POSIX time (i.e., number of seconds since
   * January 1st 1970 00:00:00 UTC).
   *
   * @generated from field: optional uint64 timestamp = 3;
   */
  timestamp: bigint;

  /**
   * String that matches the feed_info.feed_version from the GTFS feed that the real
   * time data is based on. Consumers can use this to identify which GTFS feed is
   * currently active or when a new one is available to download.
   *
   * @generated from field: optional string feed_version = 4;
   */
  feedVersion: string;
};

/**
 * Describes the message transit_realtime.FeedHeader.
 * Use `create(FeedHeaderSchema)` to create a new message.
 */
export const FeedHeaderSchema: GenMessage<FeedHeader> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 1);

/**
 * Determines whether the current fetch is incremental.  Currently,
 * DIFFERENTIAL mode is unsupported and behavior is unspecified for feeds
 * that use this mode.  There are discussions on the GTFS Realtime mailing
 * list around fully specifying the behavior of DIFFERENTIAL mode and the
 * documentation will be updated when those discussions are finalized.
 *
 * @generated from enum transit_realtime.FeedHeader.Incrementality
 */
export enum FeedHeader_Incrementality {
  /**
   * @generated from enum value: FULL_DATASET = 0;
   */
  FULL_DATASET = 0,

  /**
   * @generated from enum value: DIFFERENTIAL = 1;
   */
  DIFFERENTIAL = 1,
}

/**
 * Describes the enum transit_realtime.FeedHeader.Incrementality.
 */
export const FeedHeader_IncrementalitySchema: GenEnum<FeedHeader_Incrementality> = /*@__PURE__*/
  enumDesc(file_gtfs_realtime, 1, 0);

/**
 * A definition (or update) of an entity in the transit feed.
 *
 * @generated from message transit_realtime.FeedEntity
 */
export type FeedEntity = Message<"transit_realtime.FeedEntity"> & {
  /**
   * The ids are used only to provide incrementality support. The id should be
   * unique within a FeedMessage. Consequent FeedMessages may contain
   * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
   * FeedEntity with some id will replace the old FeedEntity with the same id
   * (or delete it - see is_deleted below).
   * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
   * feed must be specified by explicit selectors (see EntitySelector below for
   * more info).
   *
   * @generated from field: required string id = 1;
   */
  id: string;

  /**
   * Whether this entity is to be deleted. Relevant only for incremental
   * fetches.
   *
   * @generated from field: optional bool is_deleted = 2 [default = false];
   */
  isDeleted: boolean;

  /**
   * Data about the entity itself. Exactly one of the following fields must be
   * present (unless the entity is being deleted).
   *
   * @generated from field: optional transit_realtime.TripUpdate trip_update = 3;
   */
  tripUpdate?: TripUpdate;

  /**
   * @generated from field: optional transit_realtime.VehiclePosition vehicle = 4;
   */
  vehicle?: VehiclePosition;

  /**
   * @generated from field: optional transit_realtime.Alert alert = 5;
   */
  alert?: Alert;

  /**
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from field: optional transit_realtime.Shape shape = 6;
   */
  shape?: Shape;

  /**
   * @generated from field: optional transit_realtime.Stop stop = 7;
   */
  stop?: Stop;

  /**
   * @generated from field: optional transit_realtime.TripModifications trip_modifications = 8;
   */
  tripModifications?: TripModifications;
};

/**
 * Describes the message transit_realtime.FeedEntity.
 * Use `create(FeedEntitySchema)` to create a new message.
 */
export const FeedEntitySchema: GenMessage<FeedEntity> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 2);

/**
 * Realtime update of the progress of a vehicle along a trip.
 * Depending on the value of ScheduleRelationship, a TripUpdate can specify:
 * - A trip that proceeds along the schedule.
 * - A trip that proceeds along a route but has no fixed schedule.
 * - A trip that have been added or removed with regard to schedule.
 *
 * The updates can be for future, predicted arrival/departure events, or for
 * past events that already occurred.
 * Normally, updates should get more precise and more certain (see
 * uncertainty below) as the events gets closer to current time.
 * Even if that is not possible, the information for past events should be
 * precise and certain. In particular, if an update points to time in the past
 * but its update's uncertainty is not 0, the client should conclude that the
 * update is a (wrong) prediction and that the trip has not completed yet.
 *
 * Note that the update can describe a trip that is already completed.
 * To this end, it is enough to provide an update for the last stop of the trip.
 * If the time of that is in the past, the client will conclude from that that
 * the whole trip is in the past (it is possible, although inconsequential, to
 * also provide updates for preceding stops).
 * This option is most relevant for a trip that has completed ahead of schedule,
 * but according to the schedule, the trip is still proceeding at the current
 * time. Removing the updates for this trip could make the client assume
 * that the trip is still proceeding.
 * Note that the feed provider is allowed, but not required, to purge past
 * updates - this is one case where this would be practically useful.
 *
 * @generated from message transit_realtime.TripUpdate
 */
export type TripUpdate = Message<"transit_realtime.TripUpdate"> & {
  /**
   * The Trip that this message applies to. There can be at most one
   * TripUpdate entity for each actual trip instance.
   * If there is none, that means there is no prediction information available.
   * It does *not* mean that the trip is progressing according to schedule.
   *
   * @generated from field: required transit_realtime.TripDescriptor trip = 1;
   */
  trip?: TripDescriptor;

  /**
   * Additional information on the vehicle that is serving this trip.
   *
   * @generated from field: optional transit_realtime.VehicleDescriptor vehicle = 3;
   */
  vehicle?: VehicleDescriptor;

  /**
   * Updates to StopTimes for the trip (both future, i.e., predictions, and in
   * some cases, past ones, i.e., those that already happened).
   * The updates must be sorted by stop_sequence, and apply for all the
   * following stops of the trip up to the next specified one.
   *
   * Example 1:
   * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
   * delay of 0 for stop_sequence of the current stop means that the trip is
   * exactly on time.
   *
   * Example 2:
   * For the same trip instance, 3 StopTimeUpdates are provided:
   * - delay of 5 min for stop_sequence 3
   * - delay of 1 min for stop_sequence 8
   * - delay of unspecified duration for stop_sequence 10
   * This will be interpreted as:
   * - stop_sequences 3,4,5,6,7 have delay of 5 min.
   * - stop_sequences 8,9 have delay of 1 min.
   * - stop_sequences 10,... have unknown delay.
   *
   * @generated from field: repeated transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;
   */
  stopTimeUpdate: TripUpdate_StopTimeUpdate[];

  /**
   * The most recent moment at which the vehicle's real-time progress was measured
   * to estimate StopTimes in the future. When StopTimes in the past are provided,
   * arrival/departure times may be earlier than this value. In POSIX
   * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
   *
   * @generated from field: optional uint64 timestamp = 4;
   */
  timestamp: bigint;

  /**
   * The current schedule deviation for the trip.  Delay should only be
   * specified when the prediction is given relative to some existing schedule
   * in GTFS.
   *
   * Delay (in seconds) can be positive (meaning that the vehicle is late) or
   * negative (meaning that the vehicle is ahead of schedule). Delay of 0
   * means that the vehicle is exactly on time.
   *
   * Delay information in StopTimeUpdates take precedent of trip-level delay
   * information, such that trip-level delay is only propagated until the next
   * stop along the trip with a StopTimeUpdate delay value specified.
   *
   * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
   * value indicating when the delay value was last updated, in order to
   * evaluate the freshness of the data.
   *
   * NOTE: This field is still experimental, and subject to change. It may be
   * formally adopted in the future.
   *
   * @generated from field: optional int32 delay = 5;
   */
  delay: number;

  /**
   * @generated from field: optional transit_realtime.TripUpdate.TripProperties trip_properties = 6;
   */
  tripProperties?: TripUpdate_TripProperties;
};

/**
 * Describes the message transit_realtime.TripUpdate.
 * Use `create(TripUpdateSchema)` to create a new message.
 */
export const TripUpdateSchema: GenMessage<TripUpdate> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 3);

/**
 * Timing information for a single predicted event (either arrival or
 * departure).
 * Timing consists of delay and/or estimated time, and uncertainty.
 * - delay should be used when the prediction is given relative to some
 *   existing schedule in GTFS.
 * - time should be given whether there is a predicted schedule or not. If
 *   both time and delay are specified, time will take precedence
 *   (although normally, time, if given for a scheduled trip, should be
 *   equal to scheduled time in GTFS + delay).
 *
 * Uncertainty applies equally to both time and delay.
 * The uncertainty roughly specifies the expected error in true delay (but
 * note, we don't yet define its precise statistical meaning). It's possible
 * for the uncertainty to be 0, for example for trains that are driven under
 * computer timing control.
 *
 * @generated from message transit_realtime.TripUpdate.StopTimeEvent
 */
export type TripUpdate_StopTimeEvent = Message<"transit_realtime.TripUpdate.StopTimeEvent"> & {
  /**
   * Delay (in seconds) can be positive (meaning that the vehicle is late) or
   * negative (meaning that the vehicle is ahead of schedule). Delay of 0
   * means that the vehicle is exactly on time.
   *
   * @generated from field: optional int32 delay = 1;
   */
  delay: number;

  /**
   * Event as absolute time.
   * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
   * UTC).
   *
   * @generated from field: optional int64 time = 2;
   */
  time: bigint;

  /**
   * If uncertainty is omitted, it is interpreted as unknown.
   * If the prediction is unknown or too uncertain, the delay (or time) field
   * should be empty. In such case, the uncertainty field is ignored.
   * To specify a completely certain prediction, set its uncertainty to 0.
   *
   * @generated from field: optional int32 uncertainty = 3;
   */
  uncertainty: number;

  /**
   * Scheduled time for a NEW, REPLACEMENT, or DUPLICATED trip.
   * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
   * UTC).
   * Optional if TripUpdate.schedule_relationship is NEW, REPLACEMENT or DUPLICATED, forbidden otherwise.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from field: optional int64 scheduled_time = 4;
   */
  scheduledTime: bigint;
};

/**
 * Describes the message transit_realtime.TripUpdate.StopTimeEvent.
 * Use `create(TripUpdate_StopTimeEventSchema)` to create a new message.
 */
export const TripUpdate_StopTimeEventSchema: GenMessage<TripUpdate_StopTimeEvent> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 3, 0);

/**
 * Realtime update for arrival and/or departure events for a given stop on a
 * trip. Updates can be supplied for both past and future events.
 * The producer is allowed, although not required, to drop past events.
 *
 * The update is linked to a specific stop either through stop_sequence or
 * stop_id, so one of the fields below must necessarily be set.
 * See the documentation in TripDescriptor for more information.
 *
 * @generated from message transit_realtime.TripUpdate.StopTimeUpdate
 */
export type TripUpdate_StopTimeUpdate = Message<"transit_realtime.TripUpdate.StopTimeUpdate"> & {
  /**
   * Must be the same as in stop_times.txt in the corresponding GTFS feed.
   *
   * @generated from field: optional uint32 stop_sequence = 1;
   */
  stopSequence: number;

  /**
   * Must be the same as in stops.txt in the corresponding GTFS feed.
   *
   * @generated from field: optional string stop_id = 4;
   */
  stopId: string;

  /**
   * @generated from field: optional transit_realtime.TripUpdate.StopTimeEvent arrival = 2;
   */
  arrival?: TripUpdate_StopTimeEvent;

  /**
   * @generated from field: optional transit_realtime.TripUpdate.StopTimeEvent departure = 3;
   */
  departure?: TripUpdate_StopTimeEvent;

  /**
   * Expected occupancy after departure from the given stop.
   * Should be provided only for future stops.
   * In order to provide departure_occupancy_status without either arrival or
   * departure StopTimeEvents, ScheduleRelationship should be set to NO_DATA. 
   *
   * @generated from field: optional transit_realtime.VehiclePosition.OccupancyStatus departure_occupancy_status = 7;
   */
  departureOccupancyStatus: VehiclePosition_OccupancyStatus;

  /**
   * @generated from field: optional transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];
   */
  scheduleRelationship: TripUpdate_StopTimeUpdate_ScheduleRelationship;

  /**
   * Realtime updates for certain properties defined within GTFS stop_times.txt
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from field: optional transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6;
   */
  stopTimeProperties?: TripUpdate_StopTimeUpdate_StopTimeProperties;
};

/**
 * Describes the message transit_realtime.TripUpdate.StopTimeUpdate.
 * Use `create(TripUpdate_StopTimeUpdateSchema)` to create a new message.
 */
export const TripUpdate_StopTimeUpdateSchema: GenMessage<TripUpdate_StopTimeUpdate> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 3, 1);

/**
 * Provides the updated values for the stop time.
 * NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
 *
 * @generated from message transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties
 */
export type TripUpdate_StopTimeUpdate_StopTimeProperties = Message<"transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties"> & {
  /**
   * Supports real-time stop assignments. Refers to a stop_id defined in the GTFS stops.txt.
   * The new assigned_stop_id should not result in a significantly different trip experience for the end user than
   * the stop_id defined in GTFS stop_times.txt. In other words, the end user should not view this new stop_id as an
   * "unusual change" if the new stop was presented within an app without any additional context.
   * For example, this field is intended to be used for platform assignments by using a stop_id that belongs to the
   * same station as the stop originally defined in GTFS stop_times.txt.
   * To assign a stop without providing any real-time arrival or departure predictions, populate this field and set
   * StopTimeUpdate.schedule_relationship = NO_DATA.
   * If this field is populated, it is preferred to omit `StopTimeUpdate.stop_id` and use only `StopTimeUpdate.stop_sequence`. If
   * `StopTimeProperties.assigned_stop_id` and `StopTimeUpdate.stop_id` are populated, `StopTimeUpdate.stop_id` must match `assigned_stop_id`.
   * Platform assignments should be reflected in other GTFS-realtime fields as well
   * (e.g., `VehiclePosition.stop_id`).
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from field: optional string assigned_stop_id = 1;
   */
  assignedStopId: string;

  /**
   * The updated headsign of the vehicle at the stop.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from field: optional string stop_headsign = 2;
   */
  stopHeadsign: string;

  /**
   * The updated pickup of the vehicle at the stop.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from field: optional transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.DropOffPickupType pickup_type = 3;
   */
  pickupType: TripUpdate_StopTimeUpdate_StopTimeProperties_DropOffPickupType;

  /**
   * The updated drop off of the vehicle at the stop.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from field: optional transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.DropOffPickupType drop_off_type = 4;
   */
  dropOffType: TripUpdate_StopTimeUpdate_StopTimeProperties_DropOffPickupType;
};

/**
 * Describes the message transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.
 * Use `create(TripUpdate_StopTimeUpdate_StopTimePropertiesSchema)` to create a new message.
 */
export const TripUpdate_StopTimeUpdate_StopTimePropertiesSchema: GenMessage<TripUpdate_StopTimeUpdate_StopTimeProperties> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 3, 1, 0);

/**
 * @generated from enum transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.DropOffPickupType
 */
export enum TripUpdate_StopTimeUpdate_StopTimeProperties_DropOffPickupType {
  /**
   * Regularly scheduled pickup/dropoff.
   *
   * @generated from enum value: REGULAR = 0;
   */
  REGULAR = 0,

  /**
   * No pickup/dropoff available
   *
   * @generated from enum value: NONE = 1;
   */
  NONE = 1,

  /**
   * Must phone agency to arrange pickup/dropoff.
   *
   * @generated from enum value: PHONE_AGENCY = 2;
   */
  PHONE_AGENCY = 2,

  /**
   * Must coordinate with driver to arrange pickup/dropoff.
   *
   * @generated from enum value: COORDINATE_WITH_DRIVER = 3;
   */
  COORDINATE_WITH_DRIVER = 3,
}

/**
 * Describes the enum transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.DropOffPickupType.
 */
export const TripUpdate_StopTimeUpdate_StopTimeProperties_DropOffPickupTypeSchema: GenEnum<TripUpdate_StopTimeUpdate_StopTimeProperties_DropOffPickupType> = /*@__PURE__*/
  enumDesc(file_gtfs_realtime, 3, 1, 0, 0);

/**
 * The relation between the StopTimeEvents and the static schedule.
 *
 * @generated from enum transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship
 */
export enum TripUpdate_StopTimeUpdate_ScheduleRelationship {
  /**
   * The vehicle is proceeding in accordance with its static schedule of
   * stops, although not necessarily according to the times of the schedule.
   * At least one of arrival and departure must be provided. If the schedule
   * for this stop contains both arrival and departure times then so must
   * this update. Frequency-based trips (GTFS frequencies.txt with exact_times = 0)
   * should not have a SCHEDULED value and should use UNSCHEDULED instead.
   *
   * @generated from enum value: SCHEDULED = 0;
   */
  SCHEDULED = 0,

  /**
   * The stop is skipped, i.e., the vehicle will not stop at this stop.
   * Arrival and departure are optional.
   *
   * @generated from enum value: SKIPPED = 1;
   */
  SKIPPED = 1,

  /**
   * No StopTimeEvents are given for this stop.
   * The main intention for this value is to give time predictions only for
   * part of a trip, i.e., if the last update for a trip has a NO_DATA
   * specifier, then StopTimeEvents for the rest of the stops in the trip
   * are considered to be unspecified as well.
   * Neither arrival nor departure should be supplied.
   *
   * @generated from enum value: NO_DATA = 2;
   */
  NO_DATA = 2,

  /**
   * The vehicle is operating a trip defined in GTFS frequencies.txt with exact_times = 0.
   * This value should not be used for trips that are not defined in GTFS frequencies.txt,
   * or trips in GTFS frequencies.txt with exact_times = 1. Trips containing StopTimeUpdates
   * with ScheduleRelationship=UNSCHEDULED must also set TripDescriptor.ScheduleRelationship=UNSCHEDULED.
   * NOTE: This field is still experimental, and subject to change. It may be
   * formally adopted in the future.
   *
   * @generated from enum value: UNSCHEDULED = 3;
   */
  UNSCHEDULED = 3,
}

/**
 * Describes the enum transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.
 */
export const TripUpdate_StopTimeUpdate_ScheduleRelationshipSchema: GenEnum<TripUpdate_StopTimeUpdate_ScheduleRelationship> = /*@__PURE__*/
  enumDesc(file_gtfs_realtime, 3, 1, 0);

/**
 * Defines updated properties of the trip, such as a new shape_id when there is a detour. Or defines the
 * trip_id, start_date, and start_time of a DUPLICATED trip. 
 * NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
 *
 * @generated from message transit_realtime.TripUpdate.TripProperties
 */
export type TripUpdate_TripProperties = Message<"transit_realtime.TripUpdate.TripProperties"> & {
  /**
   * Defines the identifier of a new trip that is a duplicate of an existing trip defined in (CSV) GTFS trips.txt
   * but will start at a different service date and/or time (defined using the TripProperties.start_date and
   * TripProperties.start_time fields). See definition of trips.trip_id in (CSV) GTFS. Its value must be different
   * than the ones used in the (CSV) GTFS. Required if schedule_relationship=DUPLICATED, otherwise this field must not
   * be populated and will be ignored by consumers.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from field: optional string trip_id = 1;
   */
  tripId: string;

  /**
   * Service date on which the DUPLICATED trip will be run, in YYYYMMDD format. Required if
   * schedule_relationship=DUPLICATED, otherwise this field must not be populated and will be ignored by consumers.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from field: optional string start_date = 2;
   */
  startDate: string;

  /**
   * Defines the departure start time of the trip when it’s duplicated. See definition of stop_times.departure_time
   * in (CSV) GTFS. Scheduled arrival and departure times for the duplicated trip are calculated based on the offset
   * between the original trip departure_time and this field. For example, if a GTFS trip has stop A with a
   * departure_time of 10:00:00 and stop B with departure_time of 10:01:00, and this field is populated with the value
   * of 10:30:00, stop B on the duplicated trip will have a scheduled departure_time of 10:31:00. Real-time prediction
   * delay values are applied to this calculated schedule time to determine the predicted time. For example, if a
   * departure delay of 30 is provided for stop B, then the predicted departure time is 10:31:30. Real-time
   * prediction time values do not have any offset applied to them and indicate the predicted time as provided.
   * For example, if a departure time representing 10:31:30 is provided for stop B, then the predicted departure time
   * is 10:31:30. This field is required if schedule_relationship is DUPLICATED, otherwise this field must not be
   * populated and will be ignored by consumers.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from field: optional string start_time = 3;
   */
  startTime: string;

  /**
   * Specifies the identifier of the shape of the vehicle travel path when the trip shape differs from the shape specified in (CSV) GTFS
   * or to specify it in real-time when it's not provided by (CSV) GTFS, such as a vehicle that takes differing paths based on rider demand. See definition of trips.shape_id in (CSV) GTFS.
   * If a shape is neither defined in (CSV) GTFS nor in real-time, the shape is considered unknown. This field can refer to a shape defined in the (CSV) GTFS in shapes.txt or a `Shape` in the same (protobuf) real-time feed. 
   * The order of stops (stop sequences) for this trip must remain the same as (CSV) GTFS. 
   * If it refers to a `Shape` entity in the same real-time feed, the value of this field should be the one of the `shape_id` inside the entity, and _not_ the `id` of `FeedEntity`.
   * Stops that are a part of the original trip but will no longer be made, such as when a detour occurs, should be marked as schedule_relationship=SKIPPED or more details can be provided via a `TripModifications` message.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. 
   *
   * @generated from field: optional string shape_id = 4;
   */
  shapeId: string;

  /**
   * Specifies the headsign for this trip when it differs from the original.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from field: optional string trip_headsign = 5;
   */
  tripHeadsign: string;

  /**
   * Specifies the name for this trip when it differs from the original.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from field: optional string trip_short_name = 6;
   */
  tripShortName: string;
};

/**
 * Describes the message transit_realtime.TripUpdate.TripProperties.
 * Use `create(TripUpdate_TripPropertiesSchema)` to create a new message.
 */
export const TripUpdate_TripPropertiesSchema: GenMessage<TripUpdate_TripProperties> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 3, 2);

/**
 * Realtime positioning information for a given vehicle.
 *
 * @generated from message transit_realtime.VehiclePosition
 */
export type VehiclePosition = Message<"transit_realtime.VehiclePosition"> & {
  /**
   * The Trip that this vehicle is serving.
   * Can be empty or partial if the vehicle can not be identified with a given
   * trip instance.
   *
   * @generated from field: optional transit_realtime.TripDescriptor trip = 1;
   */
  trip?: TripDescriptor;

  /**
   * Additional information on the vehicle that is serving this trip.
   *
   * @generated from field: optional transit_realtime.VehicleDescriptor vehicle = 8;
   */
  vehicle?: VehicleDescriptor;

  /**
   * Current position of this vehicle.
   *
   * @generated from field: optional transit_realtime.Position position = 2;
   */
  position?: Position;

  /**
   * The stop sequence index of the current stop. The meaning of
   * current_stop_sequence (i.e., the stop that it refers to) is determined by
   * current_status.
   * If current_status is missing IN_TRANSIT_TO is assumed.
   *
   * @generated from field: optional uint32 current_stop_sequence = 3;
   */
  currentStopSequence: number;

  /**
   * Identifies the current stop. The value must be the same as in stops.txt in
   * the corresponding GTFS feed.
   *
   * @generated from field: optional string stop_id = 7;
   */
  stopId: string;

  /**
   * The exact status of the vehicle with respect to the current stop.
   * Ignored if current_stop_sequence is missing.
   *
   * @generated from field: optional transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];
   */
  currentStatus: VehiclePosition_VehicleStopStatus;

  /**
   * Moment at which the vehicle's position was measured. In POSIX time
   * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
   *
   * @generated from field: optional uint64 timestamp = 5;
   */
  timestamp: bigint;

  /**
   * @generated from field: optional transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;
   */
  congestionLevel: VehiclePosition_CongestionLevel;

  /**
   * If multi_carriage_status is populated with per-carriage OccupancyStatus,
   * then this field should describe the entire vehicle with all carriages accepting passengers considered.
   *
   * @generated from field: optional transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;
   */
  occupancyStatus: VehiclePosition_OccupancyStatus;

  /**
   * A percentage value indicating the degree of passenger occupancy in the vehicle.
   * The values are represented as an integer without decimals. 0 means 0% and 100 means 100%.
   * The value 100 should represent the total maximum occupancy the vehicle was designed for,
   * including both seated and standing capacity, and current operating regulations allow.
   * The value may exceed 100 if there are more passengers than the maximum designed capacity.
   * The precision of occupancy_percentage should be low enough that individual passengers cannot be tracked boarding or alighting the vehicle.
   * If multi_carriage_status is populated with per-carriage occupancy_percentage, 
   * then this field should describe the entire vehicle with all carriages accepting passengers considered.
   * This field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from field: optional uint32 occupancy_percentage = 10;
   */
  occupancyPercentage: number;

  /**
   * Details of the multiple carriages of this given vehicle.
   * The first occurrence represents the first carriage of the vehicle, 
   * given the current direction of travel. 
   * The number of occurrences of the multi_carriage_details 
   * field represents the number of carriages of the vehicle.
   * It also includes non boardable carriages, 
   * like engines, maintenance carriages, etc… as they provide valuable 
   * information to passengers about where to stand on a platform.
   * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from field: repeated transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;
   */
  multiCarriageDetails: VehiclePosition_CarriageDetails[];
};

/**
 * Describes the message transit_realtime.VehiclePosition.
 * Use `create(VehiclePositionSchema)` to create a new message.
 */
export const VehiclePositionSchema: GenMessage<VehiclePosition> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 4);

/**
 * Carriage specific details, used for vehicles composed of several carriages
 * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
 *
 * @generated from message transit_realtime.VehiclePosition.CarriageDetails
 */
export type VehiclePosition_CarriageDetails = Message<"transit_realtime.VehiclePosition.CarriageDetails"> & {
  /**
   * Identification of the carriage. Should be unique per vehicle.
   *
   * @generated from field: optional string id = 1;
   */
  id: string;

  /**
   * User visible label that may be shown to the passenger to help identify
   * the carriage. Example: "7712", "Car ABC-32", etc...
   * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from field: optional string label = 2;
   */
  label: string;

  /**
   * Occupancy status for this given carriage, in this vehicle
   * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from field: optional transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 3 [default = NO_DATA_AVAILABLE];
   */
  occupancyStatus: VehiclePosition_OccupancyStatus;

  /**
   * Occupancy percentage for this given carriage, in this vehicle.
   * Follows the same rules as "VehiclePosition.occupancy_percentage"
   * -1 in case data is not available for this given carriage (as protobuf defaults to 0 otherwise)
   * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from field: optional int32 occupancy_percentage = 4 [default = -1];
   */
  occupancyPercentage: number;

  /**
   * Identifies the order of this carriage with respect to the other
   * carriages in the vehicle's list of CarriageDetails.
   * The first carriage in the direction of travel must have a value of 1.
   * The second value corresponds to the second carriage in the direction
   * of travel and must have a value of 2, and so forth.
   * For example, the first carriage in the direction of travel has a value of 1.
   * If the second carriage in the direction of travel has a value of 3,
   * consumers will discard data for all carriages (i.e., the multi_carriage_details field).
   * Carriages without data must be represented with a valid carriage_sequence number and the fields 
   * without data should be omitted (alternately, those fields could also be included and set to the "no data" values).
   * This message/field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from field: optional uint32 carriage_sequence = 5;
   */
  carriageSequence: number;
};

/**
 * Describes the message transit_realtime.VehiclePosition.CarriageDetails.
 * Use `create(VehiclePosition_CarriageDetailsSchema)` to create a new message.
 */
export const VehiclePosition_CarriageDetailsSchema: GenMessage<VehiclePosition_CarriageDetails> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 4, 0);

/**
 * @generated from enum transit_realtime.VehiclePosition.VehicleStopStatus
 */
export enum VehiclePosition_VehicleStopStatus {
  /**
   * The vehicle is just about to arrive at the stop (on a stop
   * display, the vehicle symbol typically flashes).
   *
   * @generated from enum value: INCOMING_AT = 0;
   */
  INCOMING_AT = 0,

  /**
   * The vehicle is standing at the stop.
   *
   * @generated from enum value: STOPPED_AT = 1;
   */
  STOPPED_AT = 1,

  /**
   * The vehicle has departed and is in transit to the next stop.
   *
   * @generated from enum value: IN_TRANSIT_TO = 2;
   */
  IN_TRANSIT_TO = 2,
}

/**
 * Describes the enum transit_realtime.VehiclePosition.VehicleStopStatus.
 */
export const VehiclePosition_VehicleStopStatusSchema: GenEnum<VehiclePosition_VehicleStopStatus> = /*@__PURE__*/
  enumDesc(file_gtfs_realtime, 4, 0);

/**
 * Congestion level that is affecting this vehicle.
 *
 * @generated from enum transit_realtime.VehiclePosition.CongestionLevel
 */
export enum VehiclePosition_CongestionLevel {
  /**
   * @generated from enum value: UNKNOWN_CONGESTION_LEVEL = 0;
   */
  UNKNOWN_CONGESTION_LEVEL = 0,

  /**
   * @generated from enum value: RUNNING_SMOOTHLY = 1;
   */
  RUNNING_SMOOTHLY = 1,

  /**
   * @generated from enum value: STOP_AND_GO = 2;
   */
  STOP_AND_GO = 2,

  /**
   * @generated from enum value: CONGESTION = 3;
   */
  CONGESTION = 3,

  /**
   * People leaving their cars.
   *
   * @generated from enum value: SEVERE_CONGESTION = 4;
   */
  SEVERE_CONGESTION = 4,
}

/**
 * Describes the enum transit_realtime.VehiclePosition.CongestionLevel.
 */
export const VehiclePosition_CongestionLevelSchema: GenEnum<VehiclePosition_CongestionLevel> = /*@__PURE__*/
  enumDesc(file_gtfs_realtime, 4, 1);

/**
 * The state of passenger occupancy for the vehicle or carriage.
 * Individual producers may not publish all OccupancyStatus values. Therefore, consumers
 * must not assume that the OccupancyStatus values follow a linear scale.
 * Consumers should represent OccupancyStatus values as the state indicated 
 * and intended by the producer. Likewise, producers must use OccupancyStatus values that
 * correspond to actual vehicle occupancy states.
 * For describing passenger occupancy levels on a linear scale, see `occupancy_percentage`.
 * This field is still experimental, and subject to change. It may be formally adopted in the future.
 *
 * @generated from enum transit_realtime.VehiclePosition.OccupancyStatus
 */
export enum VehiclePosition_OccupancyStatus {
  /**
   * The vehicle or carriage is considered empty by most measures, and has few or no
   * passengers onboard, but is still accepting passengers.
   *
   * @generated from enum value: EMPTY = 0;
   */
  EMPTY = 0,

  /**
   * The vehicle or carriage has a large number of seats available.
   * The amount of free seats out of the total seats available to be
   * considered large enough to fall into this category is determined at the
   * discretion of the producer.
   *
   * @generated from enum value: MANY_SEATS_AVAILABLE = 1;
   */
  MANY_SEATS_AVAILABLE = 1,

  /**
   * The vehicle or carriage has a relatively small number of seats available.
   * The amount of free seats out of the total seats available to be
   * considered small enough to fall into this category is determined at the
   * discretion of the feed producer.
   *
   * @generated from enum value: FEW_SEATS_AVAILABLE = 2;
   */
  FEW_SEATS_AVAILABLE = 2,

  /**
   * The vehicle or carriage can currently accommodate only standing passengers.
   *
   * @generated from enum value: STANDING_ROOM_ONLY = 3;
   */
  STANDING_ROOM_ONLY = 3,

  /**
   * The vehicle or carriage can currently accommodate only standing passengers
   * and has limited space for them.
   *
   * @generated from enum value: CRUSHED_STANDING_ROOM_ONLY = 4;
   */
  CRUSHED_STANDING_ROOM_ONLY = 4,

  /**
   * The vehicle or carriage is considered full by most measures, but may still be
   * allowing passengers to board.
   *
   * @generated from enum value: FULL = 5;
   */
  FULL = 5,

  /**
   * The vehicle or carriage is not accepting passengers, but usually accepts passengers for boarding.
   *
   * @generated from enum value: NOT_ACCEPTING_PASSENGERS = 6;
   */
  NOT_ACCEPTING_PASSENGERS = 6,

  /**
   * The vehicle or carriage doesn't have any occupancy data available at that time.
   *
   * @generated from enum value: NO_DATA_AVAILABLE = 7;
   */
  NO_DATA_AVAILABLE = 7,

  /**
   * The vehicle or carriage is not boardable and never accepts passengers.
   * Useful for special vehicles or carriages (engine, maintenance carriage, etc…).
   *
   * @generated from enum value: NOT_BOARDABLE = 8;
   */
  NOT_BOARDABLE = 8,
}

/**
 * Describes the enum transit_realtime.VehiclePosition.OccupancyStatus.
 */
export const VehiclePosition_OccupancyStatusSchema: GenEnum<VehiclePosition_OccupancyStatus> = /*@__PURE__*/
  enumDesc(file_gtfs_realtime, 4, 2);

/**
 * An alert, indicating some sort of incident in the public transit network.
 *
 * @generated from message transit_realtime.Alert
 */
export type Alert = Message<"transit_realtime.Alert"> & {
  /**
   * Time when the alert should be shown to the user. If missing, the
   * alert will be shown as long as it appears in the feed.
   * If multiple ranges are given, the alert will be shown during all of them.
   *
   * @generated from field: repeated transit_realtime.TimeRange active_period = 1;
   */
  activePeriod: TimeRange[];

  /**
   * Entities whose users we should notify of this alert.
   *
   * @generated from field: repeated transit_realtime.EntitySelector informed_entity = 5;
   */
  informedEntity: EntitySelector[];

  /**
   * @generated from field: optional transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];
   */
  cause: Alert_Cause;

  /**
   * @generated from field: optional transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];
   */
  effect: Alert_Effect;

  /**
   * The URL which provides additional information about the alert.
   *
   * @generated from field: optional transit_realtime.TranslatedString url = 8;
   */
  url?: TranslatedString;

  /**
   * Alert header. Contains a short summary of the alert text as plain-text.
   *
   * @generated from field: optional transit_realtime.TranslatedString header_text = 10;
   */
  headerText?: TranslatedString;

  /**
   * Full description for the alert as plain-text. The information in the
   * description should add to the information of the header.
   *
   * @generated from field: optional transit_realtime.TranslatedString description_text = 11;
   */
  descriptionText?: TranslatedString;

  /**
   * Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text.
   *
   * @generated from field: optional transit_realtime.TranslatedString tts_header_text = 12;
   */
  ttsHeaderText?: TranslatedString;

  /**
   * Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text.
   *
   * @generated from field: optional transit_realtime.TranslatedString tts_description_text = 13;
   */
  ttsDescriptionText?: TranslatedString;

  /**
   * @generated from field: optional transit_realtime.Alert.SeverityLevel severity_level = 14 [default = UNKNOWN_SEVERITY];
   */
  severityLevel: Alert_SeverityLevel;

  /**
   * TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text.
   * The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. 
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from field: optional transit_realtime.TranslatedImage image = 15;
   */
  image?: TranslatedImage;

  /**
   * Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed
   * or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from field: optional transit_realtime.TranslatedString image_alternative_text = 16;
   */
  imageAlternativeText?: TranslatedString;

  /**
   * Description of the cause of the alert that allows for agency-specific language; more specific than the Cause. If cause_detail is included, then Cause must also be included.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from field: optional transit_realtime.TranslatedString cause_detail = 17;
   */
  causeDetail?: TranslatedString;

  /**
   * Description of the effect of the alert that allows for agency-specific language; more specific than the Effect. If effect_detail is included, then Effect must also be included.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from field: optional transit_realtime.TranslatedString effect_detail = 18;
   */
  effectDetail?: TranslatedString;
};

/**
 * Describes the message transit_realtime.Alert.
 * Use `create(AlertSchema)` to create a new message.
 */
export const AlertSchema: GenMessage<Alert> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 5);

/**
 * Cause of this alert. If cause_detail is included, then Cause must also be included.
 *
 * @generated from enum transit_realtime.Alert.Cause
 */
export enum Alert_Cause {
  /**
   * @generated from enum value: UNKNOWN_CAUSE = 1;
   */
  UNKNOWN_CAUSE = 1,

  /**
   * Not machine-representable.
   *
   * @generated from enum value: OTHER_CAUSE = 2;
   */
  OTHER_CAUSE = 2,

  /**
   * @generated from enum value: TECHNICAL_PROBLEM = 3;
   */
  TECHNICAL_PROBLEM = 3,

  /**
   * Public transit agency employees stopped working.
   *
   * @generated from enum value: STRIKE = 4;
   */
  STRIKE = 4,

  /**
   * People are blocking the streets.
   *
   * @generated from enum value: DEMONSTRATION = 5;
   */
  DEMONSTRATION = 5,

  /**
   * @generated from enum value: ACCIDENT = 6;
   */
  ACCIDENT = 6,

  /**
   * @generated from enum value: HOLIDAY = 7;
   */
  HOLIDAY = 7,

  /**
   * @generated from enum value: WEATHER = 8;
   */
  WEATHER = 8,

  /**
   * @generated from enum value: MAINTENANCE = 9;
   */
  MAINTENANCE = 9,

  /**
   * @generated from enum value: CONSTRUCTION = 10;
   */
  CONSTRUCTION = 10,

  /**
   * @generated from enum value: POLICE_ACTIVITY = 11;
   */
  POLICE_ACTIVITY = 11,

  /**
   * @generated from enum value: MEDICAL_EMERGENCY = 12;
   */
  MEDICAL_EMERGENCY = 12,
}

/**
 * Describes the enum transit_realtime.Alert.Cause.
 */
export const Alert_CauseSchema: GenEnum<Alert_Cause> = /*@__PURE__*/
  enumDesc(file_gtfs_realtime, 5, 0);

/**
 * What is the effect of this problem on the affected entity. If effect_detail is included, then Effect must also be included.
 *
 * @generated from enum transit_realtime.Alert.Effect
 */
export enum Alert_Effect {
  /**
   * @generated from enum value: NO_SERVICE = 1;
   */
  NO_SERVICE = 1,

  /**
   * @generated from enum value: REDUCED_SERVICE = 2;
   */
  REDUCED_SERVICE = 2,

  /**
   * We don't care about INsignificant delays: they are hard to detect, have
   * little impact on the user, and would clutter the results as they are too
   * frequent.
   *
   * @generated from enum value: SIGNIFICANT_DELAYS = 3;
   */
  SIGNIFICANT_DELAYS = 3,

  /**
   * @generated from enum value: DETOUR = 4;
   */
  DETOUR = 4,

  /**
   * @generated from enum value: ADDITIONAL_SERVICE = 5;
   */
  ADDITIONAL_SERVICE = 5,

  /**
   * @generated from enum value: MODIFIED_SERVICE = 6;
   */
  MODIFIED_SERVICE = 6,

  /**
   * @generated from enum value: OTHER_EFFECT = 7;
   */
  OTHER_EFFECT = 7,

  /**
   * @generated from enum value: UNKNOWN_EFFECT = 8;
   */
  UNKNOWN_EFFECT = 8,

  /**
   * @generated from enum value: STOP_MOVED = 9;
   */
  STOP_MOVED = 9,

  /**
   * @generated from enum value: NO_EFFECT = 10;
   */
  NO_EFFECT = 10,

  /**
   * @generated from enum value: ACCESSIBILITY_ISSUE = 11;
   */
  ACCESSIBILITY_ISSUE = 11,
}

/**
 * Describes the enum transit_realtime.Alert.Effect.
 */
export const Alert_EffectSchema: GenEnum<Alert_Effect> = /*@__PURE__*/
  enumDesc(file_gtfs_realtime, 5, 1);

/**
 * Severity of this alert.
 *
 * @generated from enum transit_realtime.Alert.SeverityLevel
 */
export enum Alert_SeverityLevel {
  /**
   * @generated from enum value: UNKNOWN_SEVERITY = 1;
   */
  UNKNOWN_SEVERITY = 1,

  /**
   * @generated from enum value: INFO = 2;
   */
  INFO = 2,

  /**
   * @generated from enum value: WARNING = 3;
   */
  WARNING = 3,

  /**
   * @generated from enum value: SEVERE = 4;
   */
  SEVERE = 4,
}

/**
 * Describes the enum transit_realtime.Alert.SeverityLevel.
 */
export const Alert_SeverityLevelSchema: GenEnum<Alert_SeverityLevel> = /*@__PURE__*/
  enumDesc(file_gtfs_realtime, 5, 2);

/**
 * A time interval. The interval is considered active at time 't' if 't' is
 * greater than or equal to the start time and less than the end time.
 *
 * @generated from message transit_realtime.TimeRange
 */
export type TimeRange = Message<"transit_realtime.TimeRange"> & {
  /**
   * Start time, in POSIX time (i.e., number of seconds since January 1st 1970
   * 00:00:00 UTC).
   * If missing, the interval starts at minus infinity.
   *
   * @generated from field: optional uint64 start = 1;
   */
  start: bigint;

  /**
   * End time, in POSIX time (i.e., number of seconds since January 1st 1970
   * 00:00:00 UTC).
   * If missing, the interval ends at plus infinity.
   *
   * @generated from field: optional uint64 end = 2;
   */
  end: bigint;
};

/**
 * Describes the message transit_realtime.TimeRange.
 * Use `create(TimeRangeSchema)` to create a new message.
 */
export const TimeRangeSchema: GenMessage<TimeRange> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 6);

/**
 * A position.
 *
 * @generated from message transit_realtime.Position
 */
export type Position = Message<"transit_realtime.Position"> & {
  /**
   * Degrees North, in the WGS-84 coordinate system.
   *
   * @generated from field: required float latitude = 1;
   */
  latitude: number;

  /**
   * Degrees East, in the WGS-84 coordinate system.
   *
   * @generated from field: required float longitude = 2;
   */
  longitude: number;

  /**
   * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
   * This can be the compass bearing, or the direction towards the next stop
   * or intermediate location.
   * This should not be direction deduced from the sequence of previous
   * positions, which can be computed from previous data.
   *
   * @generated from field: optional float bearing = 3;
   */
  bearing: number;

  /**
   * Odometer value, in meters.
   *
   * @generated from field: optional double odometer = 4;
   */
  odometer: number;

  /**
   * Momentary speed measured by the vehicle, in meters per second.
   *
   * @generated from field: optional float speed = 5;
   */
  speed: number;
};

/**
 * Describes the message transit_realtime.Position.
 * Use `create(PositionSchema)` to create a new message.
 */
export const PositionSchema: GenMessage<Position> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 7);

/**
 * A descriptor that identifies an instance of a GTFS trip, or all instances of
 * a trip along a route.
 * - To specify a single trip instance, the trip_id (and if necessary,
 *   start_time) is set. If route_id is also set, then it should be same as one
 *   that the given trip corresponds to.
 * - To specify all the trips along a given route, only the route_id should be
 *   set. Note that if the trip_id is not known, then stop sequence ids in
 *   TripUpdate are not sufficient, and stop_ids must be provided as well. In
 *   addition, absolute arrival/departure times must be provided.
 *
 * @generated from message transit_realtime.TripDescriptor
 */
export type TripDescriptor = Message<"transit_realtime.TripDescriptor"> & {
  /**
   * The trip_id from the GTFS feed that this selector refers to.
   * For non frequency-based trips, this field is enough to uniquely identify
   * the trip. For frequency-based trip, start_time and start_date might also be
   * necessary. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from
   * static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id
   * identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id.
   *
   * @generated from field: optional string trip_id = 1;
   */
  tripId: string;

  /**
   * The route_id from the GTFS that this selector refers to.
   *
   * @generated from field: optional string route_id = 5;
   */
  routeId: string;

  /**
   * The direction_id from the GTFS feed trips.txt file, indicating the
   * direction of travel for trips this selector refers to.
   *
   * @generated from field: optional uint32 direction_id = 6;
   */
  directionId: number;

  /**
   * The initially scheduled start time of this trip instance.
   * When the trip_id corresponds to a non-frequency-based trip, this field
   * should either be omitted or be equal to the value in the GTFS feed. When
   * the trip_id correponds to a frequency-based trip, the start_time must be
   * specified for trip updates and vehicle positions. If the trip corresponds
   * to exact_times=1 GTFS record, then start_time must be some multiple
   * (including zero) of headway_secs later than frequencies.txt start_time for
   * the corresponding time period. If the trip corresponds to exact_times=0,
   * then its start_time may be arbitrary, and is initially expected to be the
   * first departure of the trip. Once established, the start_time of this
   * frequency-based trip should be considered immutable, even if the first
   * departure time changes -- that time change may instead be reflected in a
   * StopTimeUpdate.
   * Format and semantics of the field is same as that of
   * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
   *
   * @generated from field: optional string start_time = 2;
   */
  startTime: string;

  /**
   * The scheduled start date of this trip instance.
   * Must be provided to disambiguate trips that are so late as to collide with
   * a scheduled trip on a next day. For example, for a train that departs 8:00
   * and 20:00 every day, and is 12 hours late, there would be two distinct
   * trips on the same time.
   * This field can be provided but is not mandatory for schedules in which such
   * collisions are impossible - for example, a service running on hourly
   * schedule where a vehicle that is one hour late is not considered to be
   * related to schedule anymore.
   * In YYYYMMDD format.
   *
   * @generated from field: optional string start_date = 3;
   */
  startDate: string;

  /**
   * @generated from field: optional transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;
   */
  scheduleRelationship: TripDescriptor_ScheduleRelationship;

  /**
   * Linkage to any modifications done to this trip (shape changes, removal or addition of stops).
   * If this field is provided, the `trip_id`, `route_id`, `direction_id`, `start_time`, `start_date` fields of the `TripDescriptor` MUST be left empty, to avoid confusion by consumers that aren't looking for the `ModifiedTripSelector` value.
   *
   * @generated from field: optional transit_realtime.TripDescriptor.ModifiedTripSelector modified_trip = 7;
   */
  modifiedTrip?: TripDescriptor_ModifiedTripSelector;
};

/**
 * Describes the message transit_realtime.TripDescriptor.
 * Use `create(TripDescriptorSchema)` to create a new message.
 */
export const TripDescriptorSchema: GenMessage<TripDescriptor> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 8);

/**
 * @generated from message transit_realtime.TripDescriptor.ModifiedTripSelector
 */
export type TripDescriptor_ModifiedTripSelector = Message<"transit_realtime.TripDescriptor.ModifiedTripSelector"> & {
  /**
   * The 'id' from the FeedEntity in which the contained TripModifications object affects this trip.
   *
   * @generated from field: optional string modifications_id = 1;
   */
  modificationsId: string;

  /**
   * The trip_id from the GTFS feed that is modified by the modifications_id
   *
   * @generated from field: optional string affected_trip_id = 2;
   */
  affectedTripId: string;

  /**
   * The initially scheduled start time of this trip instance, applied to the frequency based modified trip. Same definition as start_time in TripDescriptor.
   *
   * @generated from field: optional string start_time = 3;
   */
  startTime: string;

  /**
   * The start date of this trip instance in YYYYMMDD format, applied to the modified trip. Same definition as start_date in TripDescriptor.
   *
   * @generated from field: optional string start_date = 4;
   */
  startDate: string;
};

/**
 * Describes the message transit_realtime.TripDescriptor.ModifiedTripSelector.
 * Use `create(TripDescriptor_ModifiedTripSelectorSchema)` to create a new message.
 */
export const TripDescriptor_ModifiedTripSelectorSchema: GenMessage<TripDescriptor_ModifiedTripSelector> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 8, 0);

/**
 * The relation between this trip and the static schedule. If a trip is done
 * in accordance with temporary schedule, not reflected in GTFS, then it
 * shouldn't be marked as SCHEDULED, but likely as ADDED.
 *
 * @generated from enum transit_realtime.TripDescriptor.ScheduleRelationship
 */
export enum TripDescriptor_ScheduleRelationship {
  /**
   * Trip that is running in accordance with its GTFS schedule, or is close
   * enough to the scheduled trip to be associated with it.
   *
   * @generated from enum value: SCHEDULED = 0;
   */
  SCHEDULED = 0,

  /**
   * This value has been deprecated as the behavior was unspecified. 
   * Use DUPLICATED for an extra trip that is the same as a scheduled trip except the start date or time, 
   * or NEW for an extra trip that is unrelated to an existing trip.
   *
   * @generated from enum value: ADDED = 1 [deprecated = true];
   * @deprecated
   */
  ADDED = 1,

  /**
   * A trip that is running with no schedule associated to it (GTFS frequencies.txt exact_times=0).
   * Trips with ScheduleRelationship=UNSCHEDULED must also set all StopTimeUpdates.ScheduleRelationship=UNSCHEDULED.
   *
   * @generated from enum value: UNSCHEDULED = 2;
   */
  UNSCHEDULED = 2,

  /**
   * A trip that existed in the schedule but was removed.
   *
   * @generated from enum value: CANCELED = 3;
   */
  CANCELED = 3,

  /**
   * A trip that replaces an existing trip in the schedule.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from enum value: REPLACEMENT = 5;
   */
  REPLACEMENT = 5,

  /**
   * An extra trip that was added in addition to a running schedule, for example, to replace a broken vehicle or to
   * respond to sudden passenger load. Used with TripUpdate.TripProperties.trip_id, TripUpdate.TripProperties.start_date,
   * and TripUpdate.TripProperties.start_time to copy an existing trip from static GTFS but start at a different service
   * date and/or time. Duplicating a trip is allowed if the service related to the original trip in (CSV) GTFS
   * (in calendar.txt or calendar_dates.txt) is operating within the next 30 days. The trip to be duplicated is
   * identified via TripUpdate.TripDescriptor.trip_id. This enumeration does not modify the existing trip referenced by
   * TripUpdate.TripDescriptor.trip_id - if a producer wants to cancel the original trip, it must publish a separate
   * TripUpdate with the value of CANCELED or DELETED. If a producer wants to replace the original trip, a value of 
   * `REPLACEMENT` should be used instead.
   *
   * Trips defined in GTFS frequencies.txt with exact_times that is
   * empty or equal to 0 cannot be duplicated. The VehiclePosition.TripDescriptor.trip_id for the new trip must contain
   * the matching value from TripUpdate.TripProperties.trip_id and VehiclePosition.TripDescriptor.ScheduleRelationship
   * must also be set to DUPLICATED.
   * Existing producers and consumers that were using the ADDED enumeration to represent duplicated trips must follow
   * the migration guide (https://github.com/google/transit/tree/master/gtfs-realtime/spec/en/examples/migration-duplicated.md)
   * to transition to the DUPLICATED enumeration.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from enum value: DUPLICATED = 6;
   */
  DUPLICATED = 6,

  /**
   * A trip that existed in the schedule but was removed and must not be shown to users.
   * DELETED should be used instead of CANCELED to indicate that a transit provider would like to entirely remove
   * information about the corresponding trip from consuming applications, so the trip is not shown as cancelled to
   * riders, e.g. a trip that is entirely being replaced by another trip.
   * This designation becomes particularly important if several trips are cancelled and replaced with substitute service.
   * If consumers were to show explicit information about the cancellations it would distract from the more important
   * real-time predictions.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from enum value: DELETED = 7;
   */
  DELETED = 7,

  /**
   * An extra trip unrelated to any existing trips, for example, to respond to sudden passenger load.
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from enum value: NEW = 8;
   */
  NEW = 8,
}

/**
 * Describes the enum transit_realtime.TripDescriptor.ScheduleRelationship.
 */
export const TripDescriptor_ScheduleRelationshipSchema: GenEnum<TripDescriptor_ScheduleRelationship> = /*@__PURE__*/
  enumDesc(file_gtfs_realtime, 8, 0);

/**
 * Identification information for the vehicle performing the trip.
 *
 * @generated from message transit_realtime.VehicleDescriptor
 */
export type VehicleDescriptor = Message<"transit_realtime.VehicleDescriptor"> & {
  /**
   * Internal system identification of the vehicle. Should be unique per
   * vehicle, and can be used for tracking the vehicle as it proceeds through
   * the system.
   *
   * @generated from field: optional string id = 1;
   */
  id: string;

  /**
   * User visible label, i.e., something that must be shown to the passenger to
   * help identify the correct vehicle.
   *
   * @generated from field: optional string label = 2;
   */
  label: string;

  /**
   * The license plate of the vehicle.
   *
   * @generated from field: optional string license_plate = 3;
   */
  licensePlate: string;

  /**
   * @generated from field: optional transit_realtime.VehicleDescriptor.WheelchairAccessible wheelchair_accessible = 4 [default = NO_VALUE];
   */
  wheelchairAccessible: VehicleDescriptor_WheelchairAccessible;
};

/**
 * Describes the message transit_realtime.VehicleDescriptor.
 * Use `create(VehicleDescriptorSchema)` to create a new message.
 */
export const VehicleDescriptorSchema: GenMessage<VehicleDescriptor> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 9);

/**
 * @generated from enum transit_realtime.VehicleDescriptor.WheelchairAccessible
 */
export enum VehicleDescriptor_WheelchairAccessible {
  /**
   * The trip doesn't have information about wheelchair accessibility.
   * This is the **default** behavior. If the static GTFS contains a
   * _wheelchair_accessible_ value, it won't be overwritten.
   *
   * @generated from enum value: NO_VALUE = 0;
   */
  NO_VALUE = 0,

  /**
   * The trip has no accessibility value present.
   * This value will overwrite the value from the GTFS.
   *
   * @generated from enum value: UNKNOWN = 1;
   */
  UNKNOWN = 1,

  /**
   * The trip is wheelchair accessible.
   * This value will overwrite the value from the GTFS.
   *
   * @generated from enum value: WHEELCHAIR_ACCESSIBLE = 2;
   */
  WHEELCHAIR_ACCESSIBLE = 2,

  /**
   * The trip is **not** wheelchair accessible.
   * This value will overwrite the value from the GTFS.
   *
   * @generated from enum value: WHEELCHAIR_INACCESSIBLE = 3;
   */
  WHEELCHAIR_INACCESSIBLE = 3,
}

/**
 * Describes the enum transit_realtime.VehicleDescriptor.WheelchairAccessible.
 */
export const VehicleDescriptor_WheelchairAccessibleSchema: GenEnum<VehicleDescriptor_WheelchairAccessible> = /*@__PURE__*/
  enumDesc(file_gtfs_realtime, 9, 0);

/**
 * A selector for an entity in a GTFS feed.
 *
 * @generated from message transit_realtime.EntitySelector
 */
export type EntitySelector = Message<"transit_realtime.EntitySelector"> & {
  /**
   * The values of the fields should correspond to the appropriate fields in the
   * GTFS feed.
   * At least one specifier must be given. If several are given, then the
   * matching has to apply to all the given specifiers.
   *
   * @generated from field: optional string agency_id = 1;
   */
  agencyId: string;

  /**
   * @generated from field: optional string route_id = 2;
   */
  routeId: string;

  /**
   * corresponds to route_type in GTFS.
   *
   * @generated from field: optional int32 route_type = 3;
   */
  routeType: number;

  /**
   * @generated from field: optional transit_realtime.TripDescriptor trip = 4;
   */
  trip?: TripDescriptor;

  /**
   * @generated from field: optional string stop_id = 5;
   */
  stopId: string;

  /**
   * Corresponds to trip direction_id in GTFS trips.txt. If provided the
   * route_id must also be provided.
   *
   * @generated from field: optional uint32 direction_id = 6;
   */
  directionId: number;
};

/**
 * Describes the message transit_realtime.EntitySelector.
 * Use `create(EntitySelectorSchema)` to create a new message.
 */
export const EntitySelectorSchema: GenMessage<EntitySelector> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 10);

/**
 * An internationalized message containing per-language versions of a snippet of
 * text or a URL.
 * One of the strings from a message will be picked up. The resolution proceeds
 * as follows:
 * 1. If the UI language matches the language code of a translation,
 *    the first matching translation is picked.
 * 2. If a default UI language (e.g., English) matches the language code of a
 *    translation, the first matching translation is picked.
 * 3. If some translation has an unspecified language code, that translation is
 *    picked.
 *
 * @generated from message transit_realtime.TranslatedString
 */
export type TranslatedString = Message<"transit_realtime.TranslatedString"> & {
  /**
   * At least one translation must be provided.
   *
   * @generated from field: repeated transit_realtime.TranslatedString.Translation translation = 1;
   */
  translation: TranslatedString_Translation[];
};

/**
 * Describes the message transit_realtime.TranslatedString.
 * Use `create(TranslatedStringSchema)` to create a new message.
 */
export const TranslatedStringSchema: GenMessage<TranslatedString> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 11);

/**
 * @generated from message transit_realtime.TranslatedString.Translation
 */
export type TranslatedString_Translation = Message<"transit_realtime.TranslatedString.Translation"> & {
  /**
   * A UTF-8 string containing the message.
   *
   * @generated from field: required string text = 1;
   */
  text: string;

  /**
   * BCP-47 language code. Can be omitted if the language is unknown or if
   * no i18n is done at all for the feed. At most one translation is
   * allowed to have an unspecified language tag.
   *
   * @generated from field: optional string language = 2;
   */
  language: string;
};

/**
 * Describes the message transit_realtime.TranslatedString.Translation.
 * Use `create(TranslatedString_TranslationSchema)` to create a new message.
 */
export const TranslatedString_TranslationSchema: GenMessage<TranslatedString_Translation> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 11, 0);

/**
 * An internationalized image containing per-language versions of a URL linking to an image
 * along with meta information
 * Only one of the images from a message will be retained by consumers. The resolution proceeds
 * as follows:
 * 1. If the UI language matches the language code of a translation,
 *    the first matching translation is picked.
 * 2. If a default UI language (e.g., English) matches the language code of a
 *    translation, the first matching translation is picked.
 * 3. If some translation has an unspecified language code, that translation is
 *    picked.
 * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
 *
 * @generated from message transit_realtime.TranslatedImage
 */
export type TranslatedImage = Message<"transit_realtime.TranslatedImage"> & {
  /**
   * At least one localized image must be provided.
   *
   * @generated from field: repeated transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;
   */
  localizedImage: TranslatedImage_LocalizedImage[];
};

/**
 * Describes the message transit_realtime.TranslatedImage.
 * Use `create(TranslatedImageSchema)` to create a new message.
 */
export const TranslatedImageSchema: GenMessage<TranslatedImage> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 12);

/**
 * @generated from message transit_realtime.TranslatedImage.LocalizedImage
 */
export type TranslatedImage_LocalizedImage = Message<"transit_realtime.TranslatedImage.LocalizedImage"> & {
  /**
   * String containing an URL linking to an image
   * The image linked must be less than 2MB. 
   * If an image changes in a significant enough way that an update is required on the consumer side, the producer must update the URL to a new one.
   * The URL should be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the following http://www.w3.org/Addressing/URL/4_URI_Recommentations.html for a description of how to create fully qualified URL values.
   *
   * @generated from field: required string url = 1;
   */
  url: string;

  /**
   * IANA media type as to specify the type of image to be displayed. 
   * The type must start with "image/"
   *
   * @generated from field: required string media_type = 2;
   */
  mediaType: string;

  /**
   * BCP-47 language code. Can be omitted if the language is unknown or if
   * no i18n is done at all for the feed. At most one translation is
   * allowed to have an unspecified language tag.
   *
   * @generated from field: optional string language = 3;
   */
  language: string;
};

/**
 * Describes the message transit_realtime.TranslatedImage.LocalizedImage.
 * Use `create(TranslatedImage_LocalizedImageSchema)` to create a new message.
 */
export const TranslatedImage_LocalizedImageSchema: GenMessage<TranslatedImage_LocalizedImage> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 12, 0);

/**
 * Describes the physical path that a vehicle takes when it's not part of the (CSV) GTFS,
 * such as for a detour. Shapes belong to Trips, and consist of a sequence of shape points.
 * Tracing the points in order provides the path of the vehicle.  Shapes do not need to intercept
 * the location of Stops exactly, but all Stops on a trip should lie within a small distance of
 * the shape for that trip, i.e. close to straight line segments connecting the shape points
 * NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
 *
 * @generated from message transit_realtime.Shape
 */
export type Shape = Message<"transit_realtime.Shape"> & {
  /**
   * Identifier of the shape. Must be different than any shape_id defined in the (CSV) GTFS.
   * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
   * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from field: optional string shape_id = 1;
   */
  shapeId: string;

  /**
   * Encoded polyline representation of the shape. This polyline must contain at least two points and represent the full shape of the trip where it's used. 
   * For more information about encoded polylines, see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
   * This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
   * See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
   * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
   *
   * @generated from field: optional string encoded_polyline = 2;
   */
  encodedPolyline: string;
};

/**
 * Describes the message transit_realtime.Shape.
 * Use `create(ShapeSchema)` to create a new message.
 */
export const ShapeSchema: GenMessage<Shape> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 13);

/**
 * Describes a stop which is served by trips. All fields are as described in the GTFS-Static specification.
 * NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
 *
 * @generated from message transit_realtime.Stop
 */
export type Stop = Message<"transit_realtime.Stop"> & {
  /**
   * @generated from field: optional string stop_id = 1;
   */
  stopId: string;

  /**
   * @generated from field: optional transit_realtime.TranslatedString stop_code = 2;
   */
  stopCode?: TranslatedString;

  /**
   * @generated from field: optional transit_realtime.TranslatedString stop_name = 3;
   */
  stopName?: TranslatedString;

  /**
   * @generated from field: optional transit_realtime.TranslatedString tts_stop_name = 4;
   */
  ttsStopName?: TranslatedString;

  /**
   * @generated from field: optional transit_realtime.TranslatedString stop_desc = 5;
   */
  stopDesc?: TranslatedString;

  /**
   * @generated from field: optional float stop_lat = 6;
   */
  stopLat: number;

  /**
   * @generated from field: optional float stop_lon = 7;
   */
  stopLon: number;

  /**
   * @generated from field: optional string zone_id = 8;
   */
  zoneId: string;

  /**
   * @generated from field: optional transit_realtime.TranslatedString stop_url = 9;
   */
  stopUrl?: TranslatedString;

  /**
   * @generated from field: optional string parent_station = 11;
   */
  parentStation: string;

  /**
   * @generated from field: optional string stop_timezone = 12;
   */
  stopTimezone: string;

  /**
   * @generated from field: optional transit_realtime.Stop.WheelchairBoarding wheelchair_boarding = 13 [default = UNKNOWN];
   */
  wheelchairBoarding: Stop_WheelchairBoarding;

  /**
   * @generated from field: optional string level_id = 14;
   */
  levelId: string;

  /**
   * @generated from field: optional transit_realtime.TranslatedString platform_code = 15;
   */
  platformCode?: TranslatedString;
};

/**
 * Describes the message transit_realtime.Stop.
 * Use `create(StopSchema)` to create a new message.
 */
export const StopSchema: GenMessage<Stop> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 14);

/**
 * @generated from enum transit_realtime.Stop.WheelchairBoarding
 */
export enum Stop_WheelchairBoarding {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: AVAILABLE = 1;
   */
  AVAILABLE = 1,

  /**
   * @generated from enum value: NOT_AVAILABLE = 2;
   */
  NOT_AVAILABLE = 2,
}

/**
 * Describes the enum transit_realtime.Stop.WheelchairBoarding.
 */
export const Stop_WheelchairBoardingSchema: GenEnum<Stop_WheelchairBoarding> = /*@__PURE__*/
  enumDesc(file_gtfs_realtime, 14, 0);

/**
 * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
 *
 * @generated from message transit_realtime.TripModifications
 */
export type TripModifications = Message<"transit_realtime.TripModifications"> & {
  /**
   * A list of selected trips affected by this TripModifications.
   *
   * @generated from field: repeated transit_realtime.TripModifications.SelectedTrips selected_trips = 1;
   */
  selectedTrips: TripModifications_SelectedTrips[];

  /**
   * A list of start times in the real-time trip descriptor for the trip_id defined in trip_ids. 
   * Useful to target multiple departures of a trip_id in a frequency-based trip.
   *
   * @generated from field: repeated string start_times = 2;
   */
  startTimes: string[];

  /**
   * Dates on which the modifications occurs, in the YYYYMMDD format. Producers SHOULD only transmit detours occurring within the next week.
   * The dates provided should not be used as user-facing information, if a user-facing start and end date needs to be provided, they can be provided in the linked service alert with `service_alert_id`
   *
   * @generated from field: repeated string service_dates = 3;
   */
  serviceDates: string[];

  /**
   * A list of modifications to apply to the affected trips. 
   *
   * @generated from field: repeated transit_realtime.TripModifications.Modification modifications = 4;
   */
  modifications: TripModifications_Modification[];
};

/**
 * Describes the message transit_realtime.TripModifications.
 * Use `create(TripModificationsSchema)` to create a new message.
 */
export const TripModificationsSchema: GenMessage<TripModifications> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 15);

/**
 * A `Modification` message replaces a span of n stop times from each affected trip starting at `start_stop_selector`.
 *
 * @generated from message transit_realtime.TripModifications.Modification
 */
export type TripModifications_Modification = Message<"transit_realtime.TripModifications.Modification"> & {
  /**
   * The stop selector of the first stop_time of the original trip that is to be affected by this modification.
   * Used in conjuction with `end_stop_selector`. 
   * `start_stop_selector` is required and is used to define the reference stop used with `travel_time_to_stop`.
   *
   * @generated from field: optional transit_realtime.StopSelector start_stop_selector = 1;
   */
  startStopSelector?: StopSelector;

  /**
   * The stop selector of the last stop of the original trip that is to be affected by this modification. 
   * The selection is inclusive, so if only one stop_time is replaced by that modification, `start_stop_selector` and `end_stop_selector` must be equivalent.
   * If no stop_time is replaced, `end_stop_selector` must not be provided. It's otherwise required.
   *
   * @generated from field: optional transit_realtime.StopSelector end_stop_selector = 2;
   */
  endStopSelector?: StopSelector;

  /**
   * The number of seconds of delay to add to all departure and arrival times following the end of this modification. 
   * If multiple modifications apply to the same trip, the delays accumulate as the trip advances. 
   *
   * @generated from field: optional int32 propagated_modification_delay = 3 [default = 0];
   */
  propagatedModificationDelay: number;

  /**
   * A list of replacement stops, replacing those of the original trip. 
   * The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
   *
   * @generated from field: repeated transit_realtime.ReplacementStop replacement_stops = 4;
   */
  replacementStops: ReplacementStop[];

  /**
   * An `id` value from the `FeedEntity` message that contains the `Alert` describing this Modification for user-facing communication.
   *
   * @generated from field: optional string service_alert_id = 5;
   */
  serviceAlertId: string;

  /**
   * This timestamp identifies the moment when the modification has last been changed.
   * In POSIX time (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
   *
   * @generated from field: optional uint64 last_modified_time = 6;
   */
  lastModifiedTime: bigint;
};

/**
 * Describes the message transit_realtime.TripModifications.Modification.
 * Use `create(TripModifications_ModificationSchema)` to create a new message.
 */
export const TripModifications_ModificationSchema: GenMessage<TripModifications_Modification> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 15, 0);

/**
 * @generated from message transit_realtime.TripModifications.SelectedTrips
 */
export type TripModifications_SelectedTrips = Message<"transit_realtime.TripModifications.SelectedTrips"> & {
  /**
   * A list of trips affected with this replacement that all have the same new `shape_id`. A `TripUpdate` with `schedule_relationship=REPLACEMENT` must not already exist for the trip.
   *
   * @generated from field: repeated string trip_ids = 1;
   */
  tripIds: string[];

  /**
   * The ID of the new shape for the modified trips in this SelectedTrips. 
   * May refer to a new shape added using a `Shape` message in the same GTFS-RT feed, or to an existing shape defined in the GTFS-Static feed’s shapes.txt. 
   * If it refers to a `Shape` entity in the real-time feed, the value of this field should be the one of the `shape_id` inside the entity, and _not_ the `id` of `FeedEntity`.
   *
   * @generated from field: optional string shape_id = 2;
   */
  shapeId: string;
};

/**
 * Describes the message transit_realtime.TripModifications.SelectedTrips.
 * Use `create(TripModifications_SelectedTripsSchema)` to create a new message.
 */
export const TripModifications_SelectedTripsSchema: GenMessage<TripModifications_SelectedTrips> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 15, 1);

/**
 * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
 * Select a stop by stop sequence or by stop_id. At least one of the two values must be provided.
 *
 * @generated from message transit_realtime.StopSelector
 */
export type StopSelector = Message<"transit_realtime.StopSelector"> & {
  /**
   * Must be the same as in stop_times.txt in the corresponding GTFS feed.
   *
   * @generated from field: optional uint32 stop_sequence = 1;
   */
  stopSequence: number;

  /**
   * Must be the same as in stops.txt in the corresponding GTFS feed.
   *
   * @generated from field: optional string stop_id = 2;
   */
  stopId: string;
};

/**
 * Describes the message transit_realtime.StopSelector.
 * Use `create(StopSelectorSchema)` to create a new message.
 */
export const StopSelectorSchema: GenMessage<StopSelector> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 16);

/**
 * NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
 *
 * @generated from message transit_realtime.ReplacementStop
 */
export type ReplacementStop = Message<"transit_realtime.ReplacementStop"> & {
  /**
   * The difference in seconds between the arrival time at this stop and the arrival time at the reference stop. The reference stop is the stop prior to start_stop_selector. If the modification begins at the first stop of the trip, then the first stop of the trip is the reference stop.
   * This value MUST be monotonically increasing and may only be a negative number if the first stop of the original trip is the reference stop.
   *
   * @generated from field: optional int32 travel_time_to_stop = 1;
   */
  travelTimeToStop: number;

  /**
   * The replacement stop ID which will now be visited by the trip. May refer to a new stop added using a GTFS-RT `Stop` message in the same GTFS-RT feed, or to an existing stop defined in the (CSV) GTFS feed’s `stops.txt`.
   * If it refers to a `Shape` entity in the real-time feed, the value of this field should be the one of the `stop_id` inside the entity, and _not_ the `id` of `FeedEntity`. The replacement stop MUST have `location_type=0` (routable stops).
   *
   * @generated from field: optional string stop_id = 2;
   */
  stopId: string;
};

/**
 * Describes the message transit_realtime.ReplacementStop.
 * Use `create(ReplacementStopSchema)` to create a new message.
 */
export const ReplacementStopSchema: GenMessage<ReplacementStop> = /*@__PURE__*/
  messageDesc(file_gtfs_realtime, 17);

